
1. The Calendar Interface class is responsible for the user interface of the Calendar, collecting information from the user about an event, and constructing and adding the event to the Calendar.

2. The Full Calendar Builder class is responsible for managing the representation and construction of the Calendar.

3. A multi-map was used to efficiently search for an event by name. It stores all the vents with the event name as the key.

4. The CalendarBuilder is the object that understands the structure of the Calendar. It is responsible for jumping to a specific object. 

5. For saving the calendar to a file, the Calendar Interface writes the calendar's name and the number of years in that calendar, on the same line separated by a comma. Then, each event in the calendar is saved that file by printing the calendar's name, and all the date info on one line before ending that line to print the next event. When restoring the file from the calendar, the program first reads the name and the number of years and builds the calendar with that information as a full calendar builder would. Then, it reads all of the event lines, creating events with the information on each line, and adds them to the calendar. To successfully restore a calendar, the only information the file builder needs is for the first line to be formatted correctly, which is the name and number of years with a space in between. 


6. We used an abstract visitor class and multiple concrete visitors to the implement the functionality that a particular component in the calendar should be displayed depending on the current display of the calendar. We created one visitor for each of the displayable components(Calendar, year, month, day, event). Each of the conctrete visitor classes behaves differently depending on what was passed into it's visit() function. For example, the monthDisplayVisitor only had to define the visit function for the days and the month itself, but defines visiting a calendar and a year and an event as returning without doing anything. 

7. ToDo List: When the user inputs a value that indicates they want to see the todoList, the program first checks is the todolist pointer object inside of the calendar class is null. If it is, it creates a new todo list and returns it. If not, it returns that member variable, successfully utilizing the singleton pattern. 

8. The ToDoList class inherits from DisplayableComponent. We created a Task Class that inherits from DisplayableComponent. Because both of these classes inherit from DisplayableComponent, implementing the functionality was easy. We didn't even have to define the addComponent function to the ToDoList class, as it inherits that from the DisplayableComponent class. All we had to do was define the display and accept functions for each class. For marking the tasks complete, we just created a boolean member variable inside of the Task Class, and whenever display is called, it checked that boolean and if it was true, printed "COMPLETE" After printing the name of the task and it's date info. The way the display function uses the boolean member variable makes the ToDoList easily extensible. If we wanted to add functionality to make a task a priority, we can just add another member variable to the task class that tells us whether it is a priority. Inside the display function, if the priority member is true, we can print "*" next to the task's information, and we can add another function in the ToDoList class called prioritize with the index of the chosen task. That function will simply set the isPriority member to true and the isComplete member to false;

9. Incremental Builder was the most difficult part of this project. We began by using most of the same code as full calendar builder and then modifying it. We started with the build calendar, which, in this case, would just create a single day. Then we had to write some new functions such as buildRemainingDays, which makes the objects that have not yet been created, and it makes them whenever (and only when) they need be accessed. This way, we build the calendar incrementally. The builder has a very important effect on how the object is represented. When we had a full builder only, we were creating all the members that are part of the object (calendar in this case). With the incremental builder, only the objects that are being accessed are created. This way we save memory space. 
